## Extensions

This document discusses extension for `snappi` using [ixnetwork_restpy](https://github.com/OpenIxia/ixnetwork_restpy) as a reference.


### Definition

Existing traffic generators may not readily understand [snappi api and data models](https://github.com/open-traffic-generator/models).  
`Extensions` are python libraries that can be installed along with `snappi`, that internally    
translates any invocation of `snappi API` to corresponding `traffic generator's API`.


### Goals
1. Scripts written in `snappi` should generally be able to execute *unmodified*, when using different extensions (except during initialization).
2. Users should be able install desired extension using `pip` under `snappi` namespace.

    ```sh
    # installs snappi with HTTP transport (REST client)
    python -m pip install snappi
    # installs snappi with additional support for ixnetwork_restpy extension
    python -m pip install snappi[ixnetwork]
    # installs snappi with additional support for scapy extension
    python -m pip install snappi[scapy]
    ```

3. Users should be able to opt-in to use desired extension during test initialization.

    ```python
    import snappi

    # api.set_config() would make HTTP request to any server that implements
    # snappi API (e.g. athena)
    api = snappi.Api(host='https://localhost')
    # api.set_config() would call in-process method which translates snappi
    # request to ixn_restpy request (where host is IxNetwork API Server)
    api = snappi.Api(host='https://localhost', ext='ixnetwork')
    ```

4. Users should be able to invoke HTTP Server for any given extension.

    ```sh
    # start HTTP server listening on localhost:443
    # clients that just have snappi installed should be able to make REST calls
    # to this server
    python -m snappi -s --ext ixnetwork -c https://localhost:1109
    ```

5. (Optional) At some point, we should also be able to do following. This is not discussed further in the document.

    ```sh
    python -m pip install snappi[cli]
    # send 100 TCP packets on a given port (-p) via a given controller (-c)
    python -m snappi send -c https://localhost -p localhost:5555 -h tcp -n 100
    # or use json config to send packets
    python -m snappi send -j cfg.json
    ```


### Extension package considerations

- An extension needs to be a python package called `snappi-<extension-name>`. (e.g. `snappi-ixnetwork`)
- The name of extension package will need to be included in setup.py of `snappi` as `extra_requires`.
- The extension package must not add `snappi` as `install_requires` to its setup.py (but we may later want to include it as dev dependency).
- The extension package will still `import snappi` for data models, but it won't cause issues because `snappi` package will already be loaded when the extension is in use.


### Generated Code Changes

- `Api` class generated by `snappicommon.py` should not inherit any class (as it currently does).
- `Api` class will accept `host` and `ext` arguments during instantiation.
- If `ext` is `None`, API instance for HTTP client will be returned, otherwise extension's API instance will be returned.
- The methods in `Api` will just act as a proxy to methods in `extension.Api`
- `SnappiRestClient` being an exception, the API class in all extensions will be named `Api`.

```python
# snappicommon.py
class Api(object):
    
    def __init__(self, host=None, ext=None):
        self._api = self._get_api(host, ext)

    def _get_api(host, ext):
        if ext is None:
            return SnappiRestClient(host=host)

        try:
            c = importlib.import_module('snappi-%s' % ext)
            # create API instance for a given extension if import succeeds
            return c.Api(host=host)
        except Exception as err:
            msg = 'Please ensure %s is a supported snappi extension and was '
            msg += 'install using `pip install snappi[%s]`: %s'
            raise Exception(msg % (ext, ext, err))

    def set_config(self, content):
        return self._api.set_config(content)

    def update_config(self, content):
        return self._api.update_config(content)
```

- As a result, `SnappiRestClient` will specify its `Api` class like so:

```python
class SnappiRestClient(object):
    def __init__(self, host=None):
        self.base_url = host
        self._session = requests.Session()

    def set_config(self, content):
        return self.send_recv('post', '/config', payload=content)

    def update_config(self, content):
        return self.send_recv('patch', '/config', payload=content)

    def send_recv(self, method, relative_url, payload=None, return_object=None):
        # code for handling HTTP requests
        pass
```


### Running extension as an HTTP Server

- To allow command line execution, `__main__.py` will be introduced in generated `snappi` source.

- `__main__.py` will `argparse` and call `SnappiServer` similar to [snappiserver.py](snappi/tests/snappiserver.py).

- Based on what's parsed by `argparse`, `SnappiServer` will instantiate `Api` for a given extension (as described in previous section)

- In case of IxNetwork, `SnappiServer` is an intermediary `snappi client` and `IxN API Server`, and hence will need the host address of IxN API Server during startup.

```
+----------------+     +-------------------+      +----------------------+
|     Client     |     | snappi[ixnetwork] |      | IxNetwork API Server |
|    (snappi)    |---->|       (:443)      |----->|       (:11009)       |
+----------------+     +-------------------+      +----------------------+

```

- The second and third block in the diagram can be merged into a singe docker container.
